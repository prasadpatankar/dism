<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Pivot Table Analytics</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .options-panel {
            padding: 30px;
            background: #f8fafc;
            border-bottom: 1px solid #e2e8f0;
        }

        .options-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .option-btn {
            padding: 15px 30px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            background: white;
            color: #334155;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 150px;
        }

        .option-btn:hover {
            border-color: #3b82f6;
            background: #eff6ff;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.15);
        }

        .option-btn.selected {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            color: white;
            border-color: #1d4ed8;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }

        .main-content {
            display: none;
            padding: 30px;
        }

        .main-content.active {
            display: block;
        }

        .buckets-container {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .bucket {
            flex: 1;
            min-width: 300px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            border: 1px solid #e2e8f0;
        }

        .bucket-header {
            padding: 20px;
            border-bottom: 1px solid #e2e8f0;
            background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
            border-radius: 12px 12px 0 0;
        }

        .bucket-header h3 {
            font-size: 1.2rem;
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 5px;
        }

        .bucket-subtitle {
            font-size: 0.9rem;
            color: #64748b;
            margin-bottom: 10px;
            font-style: italic;
        }

        .search-box {
            width: 100%;
            padding: 10px 15px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 0.95rem;
            outline: none;
            transition: border-color 0.3s ease;
        }

        .search-box:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .bucket-content {
            max-height: 300px;
            overflow-y: auto;
            padding: 10px;
        }

        .bucket-item {
            padding: 12px 15px;
            margin: 5px 0;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
            position: relative;
        }

        .bucket-item:hover {
            background: #e0f2fe;
            border-color: #0ea5e9;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(14, 165, 233, 0.15);
        }

        .bucket-item.selected {
            background: #dcfce7;
            border-color: #16a34a;
            box-shadow: 0 2px 8px rgba(22, 163, 74, 0.15);
        }

        .bucket-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .double-click-hint {
            position: absolute;
            top: 2px;
            right: 5px;
            font-size: 0.7rem;
            color: #6b7280;
            background: rgba(255, 255, 255, 0.8);
            padding: 1px 4px;
            border-radius: 3px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .bucket-item:hover .double-click-hint {
            opacity: 1;
        }

        .pivot-designer {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            border: 1px solid #e2e8f0;
        }

        .pivot-designer h3 {
            font-size: 1.4rem;
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 20px;
            text-align: center;
        }

        .pivot-areas {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .drop-zone {
            min-height: 120px;
            border: 2px dashed #cbd5e1;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            background: #f8fafc;
            transition: all 0.3s ease;
            position: relative;
        }

        .drop-zone.drag-over {
            border-color: #3b82f6;
            background: #eff6ff;
            transform: scale(1.02);
        }

        .drop-zone h4 {
            font-size: 1.1rem;
            font-weight: 600;
            color: #475569;
            margin-bottom: 10px;
        }

        .drop-zone-subtitle {
            font-size: 0.85rem;
            color: #64748b;
            margin-bottom: 10px;
        }

        .drop-zone-content {
            min-height: 80px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .dropped-item {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            position: relative;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .dropped-item:hover {
            background: linear-gradient(135deg, #1d4ed8 0%, #1e40af 100%);
        }

        .aggregation-selector {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            color: white;
            padding: 2px 6px;
            font-size: 0.8rem;
            margin-left: 8px;
            cursor: pointer;
        }

        .aggregation-selector option {
            background: #1e40af;
            color: white;
        }

        .dropped-item .remove-btn {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .control-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .reset-btn {
            background: #f59e0b;
            color: white;
        }

        .reset-btn:hover {
            background: #d97706;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3);
        }

        .generate-btn {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }

        .generate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }

        .results-container {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            border: 1px solid #e2e8f0;
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .results-header h3 {
            font-size: 1.4rem;
            font-weight: 600;
            color: #1e293b;
        }

        .export-controls {
            display: flex;
            gap: 10px;
        }

        .export-btn {
            padding: 8px 16px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            background: white;
            color: #374151;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .export-btn:hover {
            background: #f3f4f6;
            border-color: #9ca3af;
        }

        .pivot-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .pivot-table th {
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            color: white;
            padding: 12px 15px;
            text-align: left;
            font-weight: 600;
            position: relative;
            cursor: pointer;
            user-select: none;
        }

        .pivot-table th:hover {
            background: linear-gradient(135deg, #334155 0%, #475569 100%);
        }

        .sort-icon {
            margin-left: 8px;
            font-size: 12px;
            opacity: 0.7;
        }

        .filter-controls {
            background: #f8fafc;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #e2e8f0;
        }

        .filter-controls h4 {
            margin-bottom: 15px;
            color: #1e293b;
            font-size: 1.1rem;
        }

        .filter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        .filter-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .filter-label {
            font-weight: 600;
            font-size: 0.9rem;
            color: #374151;
        }

        .filter-input-group {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .filter-operator {
            padding: 6px 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 0.85rem;
            background: white;
            min-width: 50px;
        }

        .filter-value {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 0.85rem;
        }

        .filter-value:focus, .filter-operator:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
            outline: none;
        }

        .clear-filters-btn {
            padding: 8px 16px;
            background: #f59e0b;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            margin-top: 10px;
        }

        .clear-filters-btn:hover {
            background: #d97706;
        }

        .pivot-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #e2e8f0;
        }

        .pivot-table tr:nth-child(even) {
            background: #f8fafc;
        }

        .pivot-table tr:hover {
            background: #e0f2fe;
        }

        .auth-panel {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
            padding: 20px;
            text-align: center;
            margin-top: 20px;
            border-radius: 12px;
        }

        .auth-btn {
            background: white;
            color: #7c3aed;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            margin: 0 10px;
            transition: all 0.3s ease;
        }

        .auth-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 255, 255, 0.3);
        }

        .status-message {
            padding: 12px 20px;
            margin: 20px 0;
            border-radius: 8px;
            font-weight: 500;
            text-align: center;
        }

        .status-success {
            background: #dcfce7;
            color: #166534;
            border: 1px solid #bbf7d0;
        }

        .status-error {
            background: #fef2f2;
            color: #991b1b;
            border: 1px solid #fecaca;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #6b7280;
        }

        .spinner {
            display: inline-block;
            width: 24px;
            height: 24px;
            border: 3px solid #e5e7eb;
            border-radius: 50%;
            border-top-color: #3b82f6;
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .pivot-areas {
                grid-template-columns: 1fr;
            }
            
            .buckets-container {
                flex-direction: column;
            }
            
            .bucket {
                min-width: auto;
            }
            
            .filter-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Advanced Pivot Table Analytics</h1>
            <p>Transform your data into actionable insights with powerful drag-and-drop or double-click analytics</p>
        </div>

        <div class="options-panel">
            <div class="options-container">
                <button class="option-btn" data-option="A">Option A</button>
                <button class="option-btn" data-option="B">Option B</button>
                <button class="option-btn" data-option="C">Option C</button>
                <button class="option-btn" data-option="D">Option D</button>
            </div>
        </div>

        <div class="main-content" id="main-content">
            <div class="buckets-container">
                <div class="bucket" id="time-bucket">
                    <div class="bucket-header">
                        <h3>Time Variables</h3>
                        <div class="bucket-subtitle">Double-click to add to Rows</div>
                        <input type="text" class="search-box" placeholder="Search time variables..." id="time-search">
                    </div>
                    <div class="bucket-content" id="time-content"></div>
                </div>

                <div class="bucket" id="factor-bucket">
                    <div class="bucket-header">
                        <h3>Factor Variables</h3>
                        <div class="bucket-subtitle">Double-click to add to Columns</div>
                        <input type="text" class="search-box" placeholder="Search factor variables..." id="factor-search">
                    </div>
                    <div class="bucket-content" id="factor-content"></div>
                </div>

                <div class="bucket" id="numeric-bucket">
                    <div class="bucket-header">
                        <h3>Numeric Variables</h3>
                        <div class="bucket-subtitle">Double-click to add to Values</div>
                        <input type="text" class="search-box" placeholder="Search numeric variables..." id="numeric-search">
                    </div>
                    <div class="bucket-content" id="numeric-content"></div>
                </div>
            </div>

            <div class="pivot-designer">
                <h3>Pivot Table Designer</h3>
                <div class="pivot-areas">
                    <div class="drop-zone" id="rows-zone">
                        <h4>Rows</h4>
                        <div class="drop-zone-subtitle">Single selection only</div>
                        <div class="drop-zone-content" id="rows-content"></div>
                    </div>
                    <div class="drop-zone" id="columns-zone">
                        <h4>Columns (Optional)</h4>
                        <div class="drop-zone-subtitle">Multiple selections allowed</div>
                        <div class="drop-zone-content" id="columns-content"></div>
                    </div>
                    <div class="drop-zone" id="values-zone">
                        <h4>Values</h4>
                        <div class="drop-zone-subtitle">Multiple selections allowed</div>
                        <div class="drop-zone-content" id="values-content"></div>
                    </div>
                </div>
                <div class="controls">
                    <button class="control-btn reset-btn" id="reset-btn">Reset Selection</button>
                    <button class="control-btn generate-btn" id="generate-btn">Generate Pivot Table</button>
                </div>
            </div>

            <div class="results-container">
                <div class="results-header">
                    <h3>Pivot Table Results</h3>
                    <div class="export-controls">
                        <button class="export-btn" id="export-csv">Export CSV</button>
                        <button class="export-btn" id="export-excel">Export Excel</button>
                        <button class="export-btn" id="custom-chart">Custom Chart</button>
                    </div>
                </div>
                <div id="results-content">
                    <div class="loading">
                        <div class="spinner"></div>
                        Please configure your pivot table and click "Generate" to see results
                    </div>
                </div>
            </div>

            <div class="auth-panel">
                <h3>Save Your Template</h3>
                <p>Sign in to save this pivot configuration for future use</p>
                <button class="auth-btn" id="signin-btn">Sign In</button>
                <button class="auth-btn" id="signup-btn">Sign Up</button>
            </div>
        </div>
    </div>

    <script>
        // Sample data for testing (with DD-MM-YYYY format dates)
        const sampleData = [
            {date: '01-01-2023', exchange: 'NSE', segment: 'EQ', instrument: 'RELIANCE', volume: 1000000, oi: 50000, turnover: 2500000, trading_days: 22, no_of_securities: 1850},
            {date: '02-01-2023', exchange: 'NSE', segment: 'EQ', instrument: 'TCS', volume: 800000, oi: 40000, turnover: 2000000, trading_days: 22, no_of_securities: 1850},
            {date: '03-01-2023', exchange: 'BSE', segment: 'EQ', instrument: 'INFY', volume: 750000, oi: 35000, turnover: 1875000, trading_days: 22, no_of_securities: 1850},
            {date: '01-02-2023', exchange: 'NSE', segment: 'FO', instrument: 'NIFTY', volume: 1200000, oi: 75000, turnover: 3000000, trading_days: 20, no_of_securities: 1820},
            {date: '02-02-2023', exchange: 'BSE', segment: 'EQ', instrument: 'HDFC', volume: 900000, oi: 45000, turnover: 2250000, trading_days: 20, no_of_securities: 1820},
            {date: '15-02-2023', exchange: 'NSE', segment: 'EQ', instrument: 'RELIANCE', volume: 1100000, oi: 55000, turnover: 2750000, trading_days: 20, no_of_securities: 1820},
            {date: '01-03-2023', exchange: 'NSE', segment: 'EQ', instrument: 'TCS', volume: 850000, oi: 42000, turnover: 2125000, trading_days: 23, no_of_securities: 1875},
            {date: '15-03-2023', exchange: 'BSE', segment: 'FO', instrument: 'BANKNIFTY', volume: 950000, oi: 60000, turnover: 2375000, trading_days: 23, no_of_securities: 1875},
            {date: '01-04-2023', exchange: 'NSE', segment: 'EQ', instrument: 'INFY', volume: 800000, oi: 38000, turnover: 2000000, trading_days: 21, no_of_securities: 1900},
            {date: '15-04-2023', exchange: 'BSE', segment: 'EQ', instrument: 'HDFC', volume: 920000, oi: 46000, turnover: 2300000, trading_days: 21, no_of_securities: 1900},
            {date: '01-05-2023', exchange: 'NSE', segment: 'EQ', instrument: 'RELIANCE', volume: 1050000, oi: 52000, turnover: 2625000, trading_days: 22, no_of_securities: 1920},
            {date: '15-06-2023', exchange: 'BSE', segment: 'EQ', instrument: 'TCS', volume: 880000, oi: 44000, turnover: 2200000, trading_days: 22, no_of_securities: 1920},
            {date: '01-07-2023', exchange: 'NSE', segment: 'FO', instrument: 'NIFTY', volume: 1150000, oi: 70000, turnover: 2875000, trading_days: 21, no_of_securities: 1940},
            {date: '15-08-2023', exchange: 'BSE', segment: 'EQ', instrument: 'INFY', volume: 780000, oi: 39000, turnover: 1950000, trading_days: 23, no_of_securities: 1960},
            {date: '01-09-2023', exchange: 'NSE', segment: 'EQ', instrument: 'HDFC', volume: 940000, oi: 47000, turnover: 2350000, trading_days: 21, no_of_securities: 1980},
            {date: '15-10-2023', exchange: 'BSE', segment: 'EQ', instrument: 'RELIANCE', volume: 1080000, oi: 54000, turnover: 2700000, trading_days: 22, no_of_securities: 2000},
            {date: '01-01-2024', exchange: 'NSE', segment: 'EQ', instrument: 'TCS', volume: 850000, oi: 42000, turnover: 2125000, trading_days: 22, no_of_securities: 1900},
            {date: '15-01-2024', exchange: 'BSE', segment: 'FO', instrument: 'BANKNIFTY', volume: 950000, oi: 60000, turnover: 2375000, trading_days: 22, no_of_securities: 1900},
            {date: '01-02-2024', exchange: 'NSE', segment: 'EQ', instrument: 'INFY', volume: 800000, oi: 38000, turnover: 2000000, trading_days: 21, no_of_securities: 1920},
            {date: '15-02-2024', exchange: 'BSE', segment: 'EQ', instrument: 'HDFC', volume: 920000, oi: 46000, turnover: 2300000, trading_days: 21, no_of_securities: 1920}
        ];

        // Variable definitions
        const timeVariables = ['Yearly', 'Quarterly', 'Monthly', 'Daily'];
        const factorVariables = ['exchange', 'segment', 'instrument'];
        const numericVariables = ['volume', 'oi', 'turnover', 'trading_days', 'no_of_securities'];

        // State management
        let currentState = {
            rows: [],
            columns: [],
            values: [],
            aggregations: {}, // Store aggregation functions for each variable
            sortColumn: null,
            sortDirection: 'asc',
            filters: {},
            tableData: [] // Store current table data for filtering/sorting
        };

        // DOM elements
        const optionBtns = document.querySelectorAll('.option-btn');
        const mainContent = document.getElementById('main-content');
        const timeContent = document.getElementById('time-content');
        const factorContent = document.getElementById('factor-content');
        const numericContent = document.getElementById('numeric-content');
        const timeSearch = document.getElementById('time-search');
        const factorSearch = document.getElementById('factor-search');
        const numericSearch = document.getElementById('numeric-search');
        const resetBtn = document.getElementById('reset-btn');
        const generateBtn = document.getElementById('generate-btn');
        const resultsContent = document.getElementById('results-content');
        const exportCsvBtn = document.getElementById('export-csv');
        const exportExcelBtn = document.getElementById('export-excel');
        const customChartBtn = document.getElementById('custom-chart');
        const signinBtn = document.getElementById('signin-btn');
        const signupBtn = document.getElementById('signup-btn');

        // Initialize app
        function init() {
            setupEventListeners();
            renderTimeVariables();
            renderFactorVariables();
            renderNumericVariables();
            setupDragAndDrop();
        }

        function setupEventListeners() {
            optionBtns.forEach(btn => {
                btn.addEventListener('click', handleOptionClick);
            });

            timeSearch.addEventListener('input', () => filterItems('time'));
            factorSearch.addEventListener('input', () => filterItems('factor'));
            numericSearch.addEventListener('input', () => filterItems('numeric'));

            resetBtn.addEventListener('click', resetPivotTable);
            generateBtn.addEventListener('click', generatePivotTable);
            exportCsvBtn.addEventListener('click', () => exportData('csv'));
            exportExcelBtn.addEventListener('click', () => exportData('excel'));
            customChartBtn.addEventListener('click', () => showCustomChart());
            signinBtn.addEventListener('click', () => showMessage('Sign in functionality would be implemented here', 'success'));
            signupBtn.addEventListener('click', () => showMessage('Sign up functionality would be implemented here', 'success'));
        }

        function handleOptionClick(event) {
            optionBtns.forEach(btn => btn.classList.remove('selected'));
            event.target.classList.add('selected');
            
            if (event.target.dataset.option === 'D') {
                mainContent.classList.add('active');
            } else {
                mainContent.classList.remove('active');
            }
        }

        function renderTimeVariables() {
            timeContent.innerHTML = '';
            timeVariables.forEach(variable => {
                const item = createInteractiveItem(variable, 'time');
                timeContent.appendChild(item);
            });
        }

        function renderFactorVariables() {
            factorContent.innerHTML = '';
            factorVariables.forEach(variable => {
                const item = createInteractiveItem(variable, 'factor');
                factorContent.appendChild(item);
            });
        }

        function renderNumericVariables() {
            numericContent.innerHTML = '';
            numericVariables.forEach(variable => {
                const item = createInteractiveItem(variable, 'numeric');
                numericContent.appendChild(item);
            });
        }

        function createInteractiveItem(text, type) {
            const item = document.createElement('div');
            item.className = 'bucket-item';
            item.textContent = text;
            item.draggable = true;
            item.dataset.type = type;
            item.dataset.value = text;
            
            // Add double-click hint
            const hint = document.createElement('span');
            hint.className = 'double-click-hint';
            hint.textContent = '2x';
            item.appendChild(hint);
            
            // Add double-click event listener
            item.addEventListener('dblclick', (e) => {
                handleDoubleClick(e, { value: text, type: type, text: text });
            });
            
            return item;
        }

        function handleDoubleClick(event, data) {
            event.preventDefault();
            event.stopPropagation();
            
            // Add visual feedback
            const item = event.currentTarget;
            item.classList.add('selected');
            setTimeout(() => item.classList.remove('selected'), 300);
            
            // Map variables to their respective buckets based on type
            if (data.type === 'time') {
                // Time variables go to rows (single selection only)
                currentState.rows = [data]; // Replace existing
                updateDropZoneDisplay('rows-zone');
                showMessage(`Time variable "${data.text}" added to Rows`, 'success');
            } else if (data.type === 'factor') {
                // Factor variables go to columns (multiple selections allowed)
                if (!currentState.columns.some(item => item.value === data.value)) {
                    currentState.columns.push(data);
                    updateDropZoneDisplay('columns-zone');
                    showMessage(`Factor variable "${data.text}" added to Columns`, 'success');
                } else {
                    showMessage(`Factor variable "${data.text}" is already in Columns`, 'error');
                }
            } else if (data.type === 'numeric') {
                // Numeric variables go to values (multiple selections allowed)
                if (!currentState.values.some(item => item.value === data.value)) {
                    currentState.values.push(data);
                    // Initialize default aggregation
                    currentState.aggregations[data.value] = 'sum';
                    updateDropZoneDisplay('values-zone');
                    showMessage(`Numeric variable "${data.text}" added to Values`, 'success');
                } else {
                    showMessage(`Numeric variable "${data.text}" is already in Values`, 'error');
                }
            }
        }

        function filterItems(bucketType) {
            const searchInput = document.getElementById(`${bucketType}-search`);
            const content = document.getElementById(`${bucketType}-content`);
            const items = content.querySelectorAll('.bucket-item');
            const searchTerm = searchInput.value.toLowerCase();

            items.forEach(item => {
                const text = item.textContent.replace('2x', '').toLowerCase(); // Remove hint text
                item.style.display = text.includes(searchTerm) ? 'block' : 'none';
            });
        }

        function setupDragAndDrop() {
            // Make items draggable
            document.addEventListener('dragstart', handleDragStart);
            document.addEventListener('dragend', handleDragEnd);

            // Setup drop zones
            const dropZones = document.querySelectorAll('.drop-zone');
            dropZones.forEach(zone => {
                zone.addEventListener('dragover', handleDragOver);
                zone.addEventListener('drop', handleDrop);
                zone.addEventListener('dragenter', handleDragEnter);
                zone.addEventListener('dragleave', handleDragLeave);
            });
        }

        function handleDragStart(event) {
            if (event.target.classList.contains('bucket-item')) {
                event.target.classList.add('dragging');
                event.dataTransfer.setData('text/plain', JSON.stringify({
                    value: event.target.dataset.value,
                    type: event.target.dataset.type,
                    text: event.target.textContent.replace('2x', '').trim() // Remove hint text
                }));
            }
        }

        function handleDragEnd(event) {
            if (event.target.classList.contains('bucket-item')) {
                event.target.classList.remove('dragging');
            }
        }

        function handleDragOver(event) {
            event.preventDefault();
        }

        function handleDragEnter(event) {
            if (event.target.classList.contains('drop-zone')) {
                event.target.classList.add('drag-over');
            }
        }

        function handleDragLeave(event) {
            if (event.target.classList.contains('drop-zone') && !event.target.contains(event.relatedTarget)) {
                event.target.classList.remove('drag-over');
            }
        }

        function handleDrop(event) {
            event.preventDefault();
            const dropZone = event.target.closest('.drop-zone');
            if (!dropZone) return;

            dropZone.classList.remove('drag-over');
            const data = JSON.parse(event.dataTransfer.getData('text/plain'));
            
            // Determine which area this is and apply mapping rules
            const zoneId = dropZone.id;
            
            if (zoneId === 'rows-zone') {
                // Only time variables can go to rows
                if (data.type === 'time') {
                    currentState.rows = [data]; // Single selection only - replace existing
                    updateDropZoneDisplay(zoneId);
                    showMessage(`Time variable "${data.text}" added to Rows`, 'success');
                } else {
                    showMessage('Only Time variables can be added to Rows', 'error');
                }
            } else if (zoneId === 'columns-zone') {
                // Only factor variables can go to columns
                if (data.type === 'factor') {
                    if (!currentState.columns.some(item => item.value === data.value)) {
                        currentState.columns.push(data);
                        updateDropZoneDisplay(zoneId);
                        showMessage(`Factor variable "${data.text}" added to Columns`, 'success');
                    } else {
                        showMessage(`Factor variable "${data.text}" is already in Columns`, 'error');
                    }
                } else {
                    showMessage('Only Factor variables can be added to Columns', 'error');
                }
            } else if (zoneId === 'values-zone') {
                // Only numeric variables can go to values
                if (data.type === 'numeric') {
                    if (!currentState.values.some(item => item.value === data.value)) {
                        currentState.values.push(data);
                        // Initialize default aggregation
                        currentState.aggregations[data.value] = 'sum';
                        updateDropZoneDisplay(zoneId);
                        showMessage(`Numeric variable "${data.text}" added to Values`, 'success');
                    } else {
                        showMessage(`Numeric variable "${data.text}" is already in Values`, 'error');
                    }
                } else {
                    showMessage('Only Numeric variables can be added to Values', 'error');
                }
            }
        }

        function updateDropZoneDisplay(zoneId) {
            const content = document.querySelector(`#${zoneId} .drop-zone-content`);
            let items;

            if (zoneId === 'rows-zone') {
                items = currentState.rows;
            } else if (zoneId === 'columns-zone') {
                items = currentState.columns;
            } else if (zoneId === 'values-zone') {
                items = currentState.values;
            }

            content.innerHTML = '';
            items.forEach((item, index) => {
                const droppedItem = document.createElement('div');
                droppedItem.className = 'dropped-item';
                
                const textSpan = document.createElement('span');
                textSpan.textContent = item.text;
                droppedItem.appendChild(textSpan);
                
                // Add aggregation selector for numeric variables in values zone
                if (zoneId === 'values-zone' && item.type === 'numeric') {
                    const aggSelect = document.createElement('select');
                    aggSelect.className = 'aggregation-selector';
                    aggSelect.innerHTML = `
                        <option value="sum">Sum</option>
                        <option value="mean">Mean</option>
                        <option value="median">Median</option>
                        <option value="min">Min</option>
                        <option value="max">Max</option>
                        <option value="count">Count</option>
                    `;
                    
                    // Set current aggregation or default to sum
                    const currentAgg = currentState.aggregations[item.value] || 'sum';
                    aggSelect.value = currentAgg;
                    
                    aggSelect.addEventListener('change', (e) => {
                        currentState.aggregations[item.value] = e.target.value;
                        // Auto-regenerate if pivot table exists
                        if (document.querySelector('.pivot-table')) {
                            generatePivotTable();
                        }
                    });
                    
                    droppedItem.appendChild(aggSelect);
                }
                
                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-btn';
                removeBtn.innerHTML = 'Ã—';
                removeBtn.onclick = () => {
                    // Remove aggregation setting when item is removed
                    if (zoneId === 'values-zone') {
                        delete currentState.aggregations[item.value];
                    }
                    items.splice(index, 1);
                    updateDropZoneDisplay(zoneId);
                };
                
                droppedItem.appendChild(removeBtn);
                content.appendChild(droppedItem);
            });
        }

        function resetPivotTable() {
            currentState.rows = [];
            currentState.columns = [];
            currentState.values = [];
            currentState.aggregations = {};
            currentState.sortColumn = null;
            currentState.sortDirection = 'asc';
            currentState.filters = {};
            currentState.tableData = [];
            
            updateDropZoneDisplay('rows-zone');
            updateDropZoneDisplay('columns-zone');
            updateDropZoneDisplay('values-zone');
            
            resultsContent.innerHTML = '<div class="loading"><div class="spinner"></div>Please configure your pivot table and click "Generate" to see results</div>';
            showMessage('Pivot table configuration has been reset', 'success');
        }

        function generatePivotTable() {
            if (currentState.rows.length === 0 || currentState.values.length === 0) {
                showMessage('Please select at least one row variable and one value variable', 'error');
                return;
            }

            showMessage('Generating pivot table...', 'success');
            
            setTimeout(() => {
                try {
                    const pivotData = createPivotTableData();
                    displayPivotTable(pivotData);
                } catch (error) {
                    console.error('Error generating pivot table:', error);
                    showMessage('Error generating pivot table. Please check your configuration.', 'error');
                }
            }, 500);
        }

        function createPivotTableData() {
            // First, process the data to add time grouping if needed
            const processedData = processDataByTimeFrequency();
            
            // Get unique values for column variables (these will become actual columns)
            const columnValues = getUniqueColumnValues(processedData);
            
            // Create row groupings first
            const rowGroups = {};
            
            processedData.forEach(row => {
                // Build the row grouping key from all row variables
                const rowKeyParts = currentState.rows.map(rowVar => {
                    if (rowVar.type === 'time') {
                        return row.timeKey || 'Unknown Time';
                    } else if (rowVar.type === 'factor') {
                        return row[rowVar.value] || 'Unknown';
                    } else if (rowVar.type === 'numeric') {
                        return row[rowVar.value] || 0;
                    }
                    return 'Unknown';
                });
                const rowKey = rowKeyParts.length > 0 ? rowKeyParts.join(' | ') : 'All Data';

                if (!rowGroups[rowKey]) {
                    rowGroups[rowKey] = [];
                }
                rowGroups[rowKey].push(row);
            });

            // Now create the final result with columns as separate fields
            const result = [];
            
            Object.keys(rowGroups).sort().forEach(rowKey => {
                const rowData = { rowKey: rowKey };
                const groupRows = rowGroups[rowKey];
                
                // For each unique column value, calculate aggregated values
                columnValues.forEach(colValue => {
                    // Filter rows that match this column value
                    const colFilteredRows = groupRows.filter(row => {
                        if (currentState.columns.length === 0) return true;
                        
                        const rowColKey = currentState.columns.map(colVar => {
                            if (colVar.type === 'time') {
                                return row.timeKey || 'Unknown Time';
                            } else if (colVar.type === 'factor') {
                                return row[colVar.value] || 'Unknown';
                            } else if (colVar.type === 'numeric') {
                                return row[colVar.value] || 0;
                            }
                            return 'Unknown';
                        }).join(' | ');
                        
                        return rowColKey === colValue;
                    });
                    
                    // Calculate aggregated values for each value variable
                    currentState.values.forEach(valueVar => {
                        const columnName = currentState.columns.length > 0 ? 
                            `${colValue}_${valueVar.value}` : valueVar.value;
                        
                        const values = colFilteredRows
                            .map(r => r[valueVar.value])
                            .filter(v => v !== undefined && v !== null && !isNaN(v));
                        
                        const aggFunction = currentState.aggregations[valueVar.value] || 'sum';
                        
                        if (values.length > 0) {
                            rowData[columnName] = calculateAggregation(values, aggFunction);
                        } else {
                            rowData[columnName] = 0;
                        }
                    });
                });
                
                result.push(rowData);
            });

            return result;
        }

        function getUniqueColumnValues(data) {
            if (currentState.columns.length === 0) {
                return ['All Data']; // Default when no column variables selected
            }
            
            const uniqueValues = new Set();
            
            data.forEach(row => {
                const colKeyParts = currentState.columns.map(colVar => {
                    if (colVar.type === 'time') {
                        return row.timeKey || 'Unknown Time';
                    } else if (colVar.type === 'factor') {
                        return row[colVar.value] || 'Unknown';
                    } else if (colVar.type === 'numeric') {
                        return row[colVar.value] || 0;
                    }
                    return 'Unknown';
                });
                const colKey = colKeyParts.join(' | ');
                uniqueValues.add(colKey);
            });
            
            return Array.from(uniqueValues).sort();
        }

        function processDataByTimeFrequency() {
            // Check if there's a time variable in rows
            const timeVariable = currentState.rows.find(r => r.type === 'time');
            
            // If no time variable, just return original data with a placeholder timeKey
            if (!timeVariable) {
                return sampleData.map(row => ({ ...row, timeKey: 'All Periods' }));
            }

            const timeFrequency = timeVariable.value;
            
            return sampleData.map(row => {
                const processedRow = { ...row };
                const dateParts = row.date.split('-');
                
                if (dateParts.length !== 3) {
                    processedRow.timeKey = row.date;
                    return processedRow;
                }
                
                const day = parseInt(dateParts[0]);
                const month = parseInt(dateParts[1]);
                const year = parseInt(dateParts[2]);
                
                if (isNaN(day) || isNaN(month) || isNaN(year)) {
                    processedRow.timeKey = row.date;
                    return processedRow;
                }

                switch (timeFrequency) {
                    case 'Yearly':
                        processedRow.timeKey = year.toString();
                        break;
                    case 'Quarterly':
                        const quarter = Math.ceil(month / 3);
                        processedRow.timeKey = `${year}-Q${quarter}`;
                        break;
                    case 'Monthly':
                        processedRow.timeKey = `${year}-${month.toString().padStart(2, '0')}`;
                        break;
                    case 'Daily':
                        processedRow.timeKey = row.date;
                        break;
                    default:
                        processedRow.timeKey = row.date;
                }

                return processedRow;
            });
        }

        function calculateAggregation(values, aggFunction) {
            if (!values || values.length === 0) return 0;
            
            const numericValues = values.filter(v => !isNaN(v) && v !== null && v !== undefined).map(v => Number(v));
            if (numericValues.length === 0) return 0;
            
            switch (aggFunction) {
                case 'sum':
                    return numericValues.reduce((sum, val) => sum + val, 0);
                case 'mean':
                    return numericValues.reduce((sum, val) => sum + val, 0) / numericValues.length;
                case 'median':
                    const sorted = [...numericValues].sort((a, b) => a - b);
                    const mid = Math.floor(sorted.length / 2);
                    return sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
                case 'min':
                    return Math.min(...numericValues);
                case 'max':
                    return Math.max(...numericValues);
                case 'count':
                    return numericValues.length;
                default:
                    return numericValues.reduce((sum, val) => sum + val, 0);
            }
        }

        function displayPivotTable(data) {
            if (data.length === 0) {
                resultsContent.innerHTML = '<div class="loading">No data available for the selected configuration</div>';
                return;
            }

            // Get unique column values for header generation
            const processedData = processDataByTimeFrequency();
            const columnValues = getUniqueColumnValues(processedData);
            const hasColumns = currentState.columns.length > 0;

            // Create expanded data rows - one row for each row-column combination
            const expandedRows = [];
            
            data.forEach(row => {
                if (hasColumns && columnValues.length > 0) {
                    // Create a separate row for each column value
                    columnValues.forEach(colValue => {
                        const newRow = {
                            rowKey: row.rowKey,
                            columnValues: colValue.split(' | ') // Split multiple column values
                        };
                        
                        // Add value data for this specific column value
                        currentState.values.forEach(val => {
                            const columnLabel = `${colValue}_${val.value}`;
                            newRow[val.value] = row[columnLabel] || 0;
                        });
                        
                        expandedRows.push(newRow);
                    });
                } else {
                    // No columns - just add the row as is
                    const newRow = {
                        rowKey: row.rowKey
                    };
                    
                    currentState.values.forEach(val => {
                        newRow[val.value] = row[val.value] || 0;
                    });
                    
                    expandedRows.push(newRow);
                }
            });

            // Store original data for filtering/sorting
            currentState.tableData = expandedRows;

            // Generate table headers metadata
            const headers = [];
            currentState.rows.forEach(rowVar => {
                headers.push({
                    key: `row_${headers.length}`,
                    label: rowVar.text,
                    type: 'text'
                });
            });
            
            if (hasColumns) {
                currentState.columns.forEach(colVar => {
                    headers.push({
                        key: `col_${headers.length}`,
                        label: colVar.text,
                        type: 'text'
                    });
                });
            }
            
            currentState.values.forEach(val => {
                const aggFunction = currentState.aggregations[val.value] || 'sum';
                headers.push({
                    key: val.value,
                    label: `${val.text} (${aggFunction.toUpperCase()})`,
                    type: 'numeric'
                });
            });

            // Apply filters and sorting
            const filteredAndSortedRows = applySortingAndFiltering(expandedRows, headers);

            // Generate HTML
            let html = '';
            
            // Add filter controls
            html += generateFilterControls(headers);
            
            // Add table
            html += '<table class="pivot-table"><thead>';
            
            // Create header row with sort functionality
            html += '<tr>';
            headers.forEach((header, index) => {
                const sortIcon = getSortIcon(index);
                html += `<th onclick="sortTable(${index})" data-column="${index}">
                    ${header.label}<span class="sort-icon">${sortIcon}</span>
                </th>`;
            });
            html += '</tr>';

            html += '</thead><tbody>';

            // Display the filtered and sorted rows
            filteredAndSortedRows.forEach(row => {
                html += '<tr>';
                
                // Split the rowKey and display each row variable value in separate columns
                const rowKeyParts = row.rowKey.split(' | ');
                currentState.rows.forEach((rowVar, index) => {
                    const cellValue = rowKeyParts[index] || '';
                    html += `<td><strong>${cellValue}</strong></td>`;
                });
                
                // Add column variable values
                if (hasColumns) {
                    currentState.columns.forEach((colVar, index) => {
                        const columnValue = row.columnValues && row.columnValues[index] ? row.columnValues[index] : '';
                        html += `<td>${columnValue}</td>`;
                    });
                }
                
                // Add value data
                currentState.values.forEach(val => {
                    const value = row[val.value] || 0;
                    const aggFunction = currentState.aggregations[val.value] || 'sum';
                    let displayValue;
                    
                    if (aggFunction === 'mean' || aggFunction === 'median') {
                        displayValue = Number(value).toFixed(2);
                    } else if (aggFunction === 'count') {
                        displayValue = Math.round(Number(value)).toLocaleString();
                    } else {
                        displayValue = Number(value).toLocaleString();
                    }
                    
                    html += `<td>${displayValue}</td>`;
                });
                
                html += '</tr>';
            });

            html += '</tbody></table>';
            resultsContent.innerHTML = html;
            
            const columnInfo = hasColumns ? ` with ${columnValues.length} column groups` : '';
            const filterInfo = filteredAndSortedRows.length !== expandedRows.length ? 
                ` (${filteredAndSortedRows.length}/${expandedRows.length} rows shown)` : '';
            showMessage(`Pivot table generated successfully with ${expandedRows.length} rows${columnInfo}${filterInfo}`, 'success');
        }

        function showCustomChart() {
            const table = document.querySelector('.pivot-table');
            if (!table) {
                showMessage('Please generate a pivot table first to create custom charts', 'error');
                return;
            }
            
            // Create a modal or new section for chart options
            const chartModal = document.createElement('div');
            chartModal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1000;
            `;
            
            const chartContent = document.createElement('div');
            chartContent.style.cssText = `
                background: white;
                padding: 30px;
                border-radius: 12px;
                max-width: 500px;
                width: 90%;
                box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
            `;
            
            chartContent.innerHTML = `
                <h3 style="margin-bottom: 20px; color: #1e293b;">Custom Chart Options</h3>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: 600;">Chart Type:</label>
                    <select id="chart-type" style="width: 100%; padding: 10px; border: 1px solid #d1d5db; border-radius: 6px;">
                        <option value="bar">Bar Chart</option>
                        <option value="line">Line Chart</option>
                        <option value="pie">Pie Chart</option>
                        <option value="area">Area Chart</option>
                    </select>
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: 600;">Chart Title:</label>
                    <input type="text" id="chart-title" placeholder="Enter chart title" 
                           style="width: 100%; padding: 10px; border: 1px solid #d1d5db; border-radius: 6px;">
                </div>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button id="cancel-chart" style="padding: 10px 20px; border: 1px solid #d1d5db; background: white; border-radius: 6px; cursor: pointer;">Cancel</button>
                    <button id="create-chart" style="padding: 10px 20px; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer;">Create Chart</button>
                </div>
            `;
            
            chartModal.appendChild(chartContent);
            document.body.appendChild(chartModal);
            
            // Event listeners for modal
            document.getElementById('cancel-chart').addEventListener('click', () => {
                document.body.removeChild(chartModal);
            });
            
            document.getElementById('create-chart').addEventListener('click', () => {
                const chartType = document.getElementById('chart-type').value;
                const chartTitle = document.getElementById('chart-title').value || 'Custom Chart';
                
                showMessage(`${chartType.charAt(0).toUpperCase() + chartType.slice(1)} chart "${chartTitle}" would be created here using a charting library like Chart.js or D3.js`, 'success');
                document.body.removeChild(chartModal);
            });
            
            // Close modal when clicking outside
            chartModal.addEventListener('click', (e) => {
                if (e.target === chartModal) {
                    document.body.removeChild(chartModal);
                }
            });
        }

        function exportData(format) {
            const table = document.querySelector('.pivot-table');
            if (!table) {
                showMessage('Please generate a pivot table first', 'error');
                return;
            }

            if (format === 'csv') {
                exportToCSV(table);
            } else if (format === 'excel') {
                showMessage('Excel export functionality would be implemented with a library like SheetJS', 'success');
            }
        }

        function exportToCSV(table) {
            let csv = '';
            const rows = table.querySelectorAll('tr');
            
            rows.forEach(row => {
                const cells = row.querySelectorAll('th, td');
                const rowData = Array.from(cells).map(cell => {
                    return '"' + cell.textContent.replace(/"/g, '""') + '"';
                });
                csv += rowData.join(',') + '\n';
            });

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'pivot_table_export.csv';
            link.click();
            window.URL.revokeObjectURL(url);
            
            showMessage('CSV file downloaded successfully', 'success');
        }

        function showMessage(text, type) {
            const existingMessage = document.querySelector('.status-message');
            if (existingMessage) {
                existingMessage.remove();
            }

            const message = document.createElement('div');
            message.className = `status-message status-${type}`;
            message.textContent = text;
            
            const mainContent = document.getElementById('main-content');
            mainContent.insertBefore(message, mainContent.firstChild);
            
            setTimeout(() => {
                message.remove();
            }, 3000);
        }

        // Sorting and filtering functions
        function getSortIcon(columnIndex) {
            if (currentState.sortColumn === columnIndex) {
                return currentState.sortDirection === 'asc' ? 'â–²' : 'â–¼';
            }
            return 'â–¼â–²';
        }

        function sortTable(columnIndex) {
            // Toggle sort direction if same column, otherwise set to ascending
            if (currentState.sortColumn === columnIndex) {
                currentState.sortDirection = currentState.sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                currentState.sortColumn = columnIndex;
                currentState.sortDirection = 'asc';
            }
            
            // Regenerate table with new sort
            redrawTable();
        }

        function generateFilterControls(headers) {
            let html = '<div class="filter-controls">';
            html += '<h4>Advanced Filters</h4>';
            html += '<div class="filter-grid">';
            
            headers.forEach((header, index) => {
                const currentFilter = currentState.filters[index] || { operator: 'contains', value: '' };
                
                html += `<div class="filter-item">`;
                html += `<div class="filter-label">${header.label}</div>`;
                html += `<div class="filter-input-group">`;
                
                if (header.type === 'numeric') {
                    html += `<select class="filter-operator" onchange="updateFilter(${index}, this.value, document.getElementById('filter-${index}').value)">
                        <option value="=" ${currentFilter.operator === '=' ? 'selected' : ''}>Equals (=)</option>
                        <option value=">" ${currentFilter.operator === '>' ? 'selected' : ''}>Greater than (&gt;)</option>
                        <option value=">=" ${currentFilter.operator === '>=' ? 'selected' : ''}>Greater or equal (&gt;=)</option>
                        <option value="<" ${currentFilter.operator === '<' ? 'selected' : ''}>Less than (&lt;)</option>
                        <option value="<=" ${currentFilter.operator === '<=' ? 'selected' : ''}>Less or equal (&lt;=)</option>
                        <option value="!=" ${currentFilter.operator === '!=' ? 'selected' : ''}>Not equal (!=)</option>
                    </select>`;
                } else {
                    html += `<select class="filter-operator" onchange="updateFilter(${index}, this.value, document.getElementById('filter-${index}').value)">
                        <option value="contains" ${currentFilter.operator === 'contains' ? 'selected' : ''}>Contains</option>
                        <option value="equals" ${currentFilter.operator === 'equals' ? 'selected' : ''}>Equals</option>
                        <option value="starts" ${currentFilter.operator === 'starts' ? 'selected' : ''}>Starts with</option>
                        <option value="ends" ${currentFilter.operator === 'ends' ? 'selected' : ''}>Ends with</option>
                        <option value="not_contains" ${currentFilter.operator === 'not_contains' ? 'selected' : ''}>Does not contain</option>
                    </select>`;
                }
                
                const placeholder = header.type === 'numeric' ? 'Enter number...' : 'Enter text...';
                html += `<input type="text" id="filter-${index}" class="filter-value" 
                    placeholder="${placeholder}" 
                    value="${currentFilter.value}" 
                    onkeyup="updateFilter(${index}, document.querySelector('.filter-operator').value, this.value)">`;
                
                html += `</div></div>`;
            });
            
            html += '</div>';
            html += '<button class="clear-filters-btn" onclick="clearAllFilters()">Clear All Filters</button>';
            html += '</div>';
            
            return html;
        }

        function updateFilter(columnIndex, operator, value) {
            if (value.trim() === '') {
                delete currentState.filters[columnIndex];
            } else {
                currentState.filters[columnIndex] = { operator: operator, value: value.trim() };
            }
            
            redrawTable();
        }

        function clearAllFilters() {
            currentState.filters = {};
            redrawTable();
        }

        function redrawTable() {
            // Get headers metadata
            const headers = [];
            currentState.rows.forEach(rowVar => {
                headers.push({
                    key: `row_${headers.length}`,
                    label: rowVar.text,
                    type: 'text'
                });
            });
            
            const hasColumns = currentState.columns.length > 0;
            if (hasColumns) {
                currentState.columns.forEach(colVar => {
                    headers.push({
                        key: `col_${headers.length}`,
                        label: colVar.text,
                        type: 'text'
                    });
                });
            }
            
            currentState.values.forEach(val => {
                const aggFunction = currentState.aggregations[val.value] || 'sum';
                headers.push({
                    key: val.value,
                    label: `${val.text} (${aggFunction.toUpperCase()})`,
                    type: 'numeric'
                });
            });

            // Apply filters and sorting to current data
            const filteredAndSortedRows = applySortingAndFiltering(currentState.tableData, headers);

            // Generate HTML
            let html = '';
            
            // Add filter controls
            html += generateFilterControls(headers);
            
            // Add table
            html += '<table class="pivot-table"><thead>';
            
            // Create header row with sort functionality
            html += '<tr>';
            headers.forEach((header, index) => {
                const sortIcon = getSortIcon(index);
                html += `<th onclick="sortTable(${index})" data-column="${index}">
                    ${header.label}<span class="sort-icon">${sortIcon}</span>
                </th>`;
            });
            html += '</tr>';

            html += '</thead><tbody>';

            // Display the filtered and sorted rows
            filteredAndSortedRows.forEach(row => {
                html += '<tr>';
                
                // Split the rowKey and display each row variable value in separate columns
                const rowKeyParts = row.rowKey.split(' | ');
                currentState.rows.forEach((rowVar, index) => {
                    const cellValue = rowKeyParts[index] || '';
                    html += `<td><strong>${cellValue}</strong></td>`;
                });
                
                // Add column variable values
                if (hasColumns) {
                    currentState.columns.forEach((colVar, index) => {
                        const columnValue = row.columnValues && row.columnValues[index] ? row.columnValues[index] : '';
                        html += `<td>${columnValue}</td>`;
                    });
                }
                
                // Add value data
                currentState.values.forEach(val => {
                    const value = row[val.value] || 0;
                    const aggFunction = currentState.aggregations[val.value] || 'sum';
                    let displayValue;
                    
                    if (aggFunction === 'mean' || aggFunction === 'median') {
                        displayValue = Number(value).toFixed(2);
                    } else if (aggFunction === 'count') {
                        displayValue = Math.round(Number(value)).toLocaleString();
                    } else {
                        displayValue = Number(value).toLocaleString();
                    }
                    
                    html += `<td>${displayValue}</td>`;
                });
                
                html += '</tr>';
            });

            html += '</tbody></table>';
            resultsContent.innerHTML = html;
            
            const filterInfo = filteredAndSortedRows.length !== currentState.tableData.length ? 
                ` (${filteredAndSortedRows.length}/${currentState.tableData.length} rows shown)` : '';
            showMessage(`Table updated${filterInfo}`, 'success');
        }

        function applySortingAndFiltering(rows, headers) {
            let processedRows = [...rows];
            
            // Apply filters first
            processedRows = applyFilters(processedRows, headers);
            
            // Then apply sorting
            processedRows = applySorting(processedRows, headers);
            
            return processedRows;
        }

        function applyFilters(rows, headers) {
            if (Object.keys(currentState.filters).length === 0) return rows;
            
            return rows.filter(row => {
                return Object.entries(currentState.filters).every(([columnIndex, filter]) => {
                    const colIndex = parseInt(columnIndex);
                    const header = headers[colIndex];
                    let cellValue = getCellValue(row, colIndex, header);
                    
                    return evaluateFilter(cellValue, filter, header.type);
                });
            });
        }

        function applySorting(rows, headers) {
            if (currentState.sortColumn === null) return rows;
            
            const header = headers[currentState.sortColumn];
            
            return [...rows].sort((a, b) => {
                let valueA = getCellValue(a, currentState.sortColumn, header);
                let valueB = getCellValue(b, currentState.sortColumn, header);
                
                // Handle numeric vs string comparison
                let comparison;
                if (header.type === 'numeric') {
                    const numA = Number(valueA);
                    const numB = Number(valueB);
                    comparison = numA - numB;
                } else {
                    comparison = String(valueA).localeCompare(String(valueB));
                }
                
                return currentState.sortDirection === 'asc' ? comparison : -comparison;
            });
        }

        function getCellValue(row, columnIndex, header) {
            const rowKeyParts = row.rowKey.split(' | ');
            const hasColumns = currentState.columns.length > 0;
            const totalRowCols = currentState.rows.length + (hasColumns ? currentState.columns.length : 0);
            
            if (columnIndex < currentState.rows.length) {
                // Row variable
                return rowKeyParts[columnIndex] || '';
            } else if (hasColumns && columnIndex < totalRowCols) {
                // Column variable
                const colIndex = columnIndex - currentState.rows.length;
                return row.columnValues && row.columnValues[colIndex] ? row.columnValues[colIndex] : '';
            } else {
                // Value variable
                const valIndex = columnIndex - totalRowCols;
                const valueVar = currentState.values[valIndex];
                if (valueVar) {
                    return row[valueVar.value] || 0;
                }
                return '';
            }
        }

        function evaluateFilter(cellValue, filter, columnType) {
            const { operator, value } = filter;
            
            if (columnType === 'numeric') {
                const cellNum = Number(cellValue);
                const filterNum = Number(value);
                
                if (isNaN(cellNum) || isNaN(filterNum)) return true;
                
                switch (operator) {
                    case '=': return cellNum === filterNum;
                    case '>': return cellNum > filterNum;
                    case '>=': return cellNum >= filterNum;
                    case '<': return cellNum < filterNum;
                    case '<=': return cellNum <= filterNum;
                    case '!=': return cellNum !== filterNum;
                    default: return true;
                }
            } else {
                const cellStr = String(cellValue).toLowerCase();
                const filterStr = value.toLowerCase();
                
                switch (operator) {
                    case 'contains': return cellStr.includes(filterStr);
                    case 'equals': return cellStr === filterStr;
                    case 'starts': return cellStr.startsWith(filterStr);
                    case 'ends': return cellStr.endsWith(filterStr);
                    case 'not_contains': return !cellStr.includes(filterStr);
                    default: return true;
                }
            }
        }

        // Initialize the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', init);

        // Also run init immediately in case DOM is already loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

    </script>
</body>
</html>